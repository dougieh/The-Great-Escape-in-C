/* main.c
 *
 * Minimal front-end for The Great Escape.
 *
 * (c) David Thomas, 2017-2018.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifndef __riscos
#include <sys/time.h>
#else
#include "swis.h"
#endif

#include "ZXSpectrum/Spectrum.h"
#include "ZXSpectrum/Keyboard.h"
#include "ZXSpectrum/Kempston.h"

#include "TheGreatEscape/TheGreatEscape.h"

// -----------------------------------------------------------------------------

// Configuration
//
#define GAMEWIDTH         256
#define GAMEHEIGHT        192

// -----------------------------------------------------------------------------

typedef struct
{
  zxspectrum_t *zx;
  tgestate_t   *game;

  zxkeyset_t    keys;
  zxkempston_t  kempston;

  int           paused; // bool
  int           quit; // bool
  int           menu; // bool

  int          *sprite;
  unsigned int trans[16];

  int           sleep_us; // us to sleep for on the next loop
}
state_t;

// -----------------------------------------------------------------------------

static state_t state;

static int keystroke_time;

// -----------------------------------------------------------------------------

static void draw_handler(const zxbox_t *dirty,
                         void          *opaque)
{
  static int first = 1;

  state_t  *state = opaque;
  uint32_t *pixels;
  char      clip[9];

  pixels = zxspectrum_claim_screen(state->zx);

  if (first)
  {
    static const zxbox_t all = { 0, 0, 256, 192 };
    first = 0;
    dirty = &all;
  }

// copy across only the dirty rectangle
//

  char *dst;
  char *src;
  size_t rowbytes;
  int y;
  int w;
  int dx0, dx1, dy0, dy1;

  dst = (char *) state->sprite + 16 + 44 + (16 * 4 * 2);
  src = (char *) pixels;
  rowbytes = 256 / 2;

  dx0 = (dirty->x0    ) >> 1; // round down to byte boundary
  dx1 = (dirty->x1 + 1) >> 1; // round up
  w = dx1 - dx0; // width in bytes

  // double check these inversions
  dy0 = 192 - (dirty->y1);
  dy1 = 192 - (dirty->y0);

  for (y = dy0; y < dy1; y++)
    memcpy(dst + y * rowbytes + dx0, src + y * rowbytes + dx0, w);

// set a clip region
//

  int x0,y0,x1,y1;

  x0 = dirty->x0 * 2; // scale to OS units
  y0 = dirty->y0 * 2; // scale to OS units
  x1 = dirty->x1 * 2; // scale to OS units
  y1 = dirty->y1 * 2; // scale to OS units

  clip[0] = 24;
  clip[1] = x0;
  clip[2] = x0 >> 8;
  clip[3] = y0;
  clip[4] = y0 >> 8;
  clip[5] = (x1 - 1);
  clip[6] = (x1 - 1) >> 8;
  clip[7] = (y1 - 1);
  clip[8] = (y1 - 1) >> 8;
  _swix(OS_WriteN,
        _INR(0,1),
        clip,
        9);

// plot
//

  _swi(OS_SpriteOp,
       _INR(0,7),
       0x200 + 52,
       state->sprite,
       state->sprite + 4,
       0,0, // x,y
       0, // plot: overwrite
       0, // 1:1 scaling
       state->trans
       );

  zxspectrum_release_screen(state->zx);
}

static void stamp_handler(void *opaque)
{
}

static void sleep_handler(int durationTStates, void *opaque)
{
    // return immediately: run the game as fast as possible
}

static int key_handler(uint16_t port, void *opaque)
{
    if (port == port_KEMPSTON_JOYSTICK)
        return 0; // active high (zeroes by default)

    keystroke_time++;

    // first send a '2' to select Kempston joystick mode
    if (keystroke_time < 3 && port == port_KEYBOARD_12345)
        return 0x1F ^ 2;

    // then send a '0' to start the game
    if (keystroke_time < 6 && port == port_KEYBOARD_09876)
        return 0x1F ^ 1;

    return 0x1F;
}

static void border_handler(int colour, void *opaque)
{
}

static void speaker_handler(int on_off, void *opaque)
{
    // dump the speaker pulses in binary
    // putc('0' + on_off, stderr);
}

// -----------------------------------------------------------------------------

static int get_ms(void)
{
#ifndef __riscos
  struct timeval tv;

  gettimeofday(&tv, NULL);

  return tv.tv_sec * 1000 + tv.tv_usec / 1000;
#else
  unsigned int t;

  _swix(OS_ReadMonotonicTime, _OUT(0), &t); // returns centisecs, not ms

  return t;
#endif
}

static void main_loop(void *opaque)
{
  state_t *state = opaque;

#if 0
  {
    SDL_Event event;

    // Consume all pending events
    while (SDL_PollEvent(&event))
    {
      switch (event.type)
      {
        case SDL_QUIT:
          state->quit = 1;
          SDL_Log("Quitting after %i ticks", event.quit.timestamp);
          break;

        case SDL_WINDOWEVENT:
          PrintEvent(&event);
          break;

        case SDL_KEYDOWN:
        case SDL_KEYUP:
          sdl_key_pressed(state, &event.key);
          break;

        case SDL_TEXTEDITING:
        case SDL_TEXTINPUT:
          break;

        case SDL_MOUSEMOTION:
        case SDL_MOUSEBUTTONDOWN:
        case SDL_MOUSEBUTTONUP:
        case SDL_MOUSEWHEEL:
          break;

        default:
          printf("Unhandled event code {%d}\n", event.type);
          break;
      }
    }
#endif

    if (state->quit)
      return;

    if (state->menu)
    {
      if (tge_menu(state->game) > 0)
      {
        printf("Running setup 2 (then main)...\n");
        tge_setup2(state->game);
        state->menu = 0;
      }
    }
    else
    {
      tge_main(state->game);
    }

    /* Update the texture and render it */

#if 0
    /* Clear screen */
    // TODO: This ought to be the border colour, but TGE's is always black.
    SDL_SetRenderDrawColor(state->renderer, 0x00, 0x00, 0x00, 0xFF);
    SDL_RenderClear(state->renderer);

    /* Offset the image */
    // Note that this will inhibit image stretching.

    SDL_RenderCopy(state->renderer, state->texture, NULL, &dstrect);
    SDL_RenderPresent(state->renderer);

    SDL_Delay(1000 / FPS);
  }
#endif
}

int main(void)
{
  static const zxconfig_t zxconfig =
  {
    &state, /* opaque */
    &draw_handler,
    &stamp_handler,
    &sleep_handler,
    &key_handler,
    &border_handler,
    &speaker_handler
  };
  tgeconfig_t config;

  printf("THE GREAT ESCAPE\n");
  printf("================\n");

  printf("Initialising...\n");

  config.width  = GAMEWIDTH  / 8;
  config.height = GAMEHEIGHT / 8;

  state.keys      = 0ULL;
  state.kempston  = 0;
  state.paused    = 0;
  state.quit      = 0;
  state.menu      = 1;

  size_t sprareasz;
  int *p;

  sprareasz = (16) + (44) + (16 * 4 * 2) + (256 * 192 / 2);

  state.sprite = malloc(sprareasz);
  if (state.sprite == NULL)
    goto failure; // oom

  p = state.sprite;

  *p++ = sprareasz;
  *p++ = 1;
  *p++ = 16;
  *p++ = sprareasz;

  *p++ = (44) + (16 * 4 * 2) + (256 * 192 / 2); // offset to next spr
  *p++ = ('x' << 8) | ('z'); // name
  *p++ = 0;
  *p++ = 0;
  *p++ = 32 - 1; // width in words - 1
  *p++ = 192 - 1; // height in scanlines - 1
  *p++ = 0; // first bit used
  *p++ = 31; // last bit used
  *p++ = (44) + (16 * 4 * 2); // offset to spr
  *p++ = (44) + (16 * 4 * 2); // offset to mask (none)
  *p++ = 27;

  static const unsigned int palette[16 * 2] =
  {
    0x00000000,
    0x00000000,
    0xCC000000,
    0xCC000000,
    0x0000CC00,
    0x0000CC00,
    0xCC00CC00,
    0xCC00CC00,
    0x00CC0000,
    0x00CC0000,
    0xCCCC0000,
    0xCCCC0000,
    0x00CCCC00,
    0x00CCCC00,
    0xCCCCCC00,
    0xCCCCCC00,
    0x00000000,
    0x00000000,
    0xFF000000,
    0xFF000000,
    0x0000FF00,
    0x0000FF00,
    0xFF00FF00,
    0xFF00FF00,
    0x00FF0000,
    0x00FF0000,
    0xFFFF0000,
    0xFFFF0000,
    0x00FFFF00,
    0x00FFFF00,
    0xFFFFFF00,
    0xFFFFFF00
  };

  memcpy(p, palette, 16 * 2 * 4);

  _swi(ColourTrans_GenerateTable,
       _INR(0,5),
       state.sprite,
       state.sprite + 4,
       -1,
       -1,
       state.trans,
       1);

  state.zx = zxspectrum_create(&zxconfig);
  if (state.zx == NULL)
    goto failure;

  state.game = tge_create(state.zx, &config);
  if (state.game == NULL)
    goto failure;

  printf("Running setup 1...\n");
  tge_setup(state.game);

  printf("Running main loop...\n");
  while (!state.quit)
    main_loop(&state);

  tge_destroy(state.game);
  zxspectrum_destroy(state.zx);

  printf("(quit)\n");

  exit(EXIT_SUCCESS);


failure:

  exit(EXIT_FAILURE);
}

// vim: ts=8 sts=2 sw=2 et
